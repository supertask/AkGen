#pragma kernel GetPoints
#pragma kernel ResetCellularNoise
#pragma kernel ResetExistingLineMap
#pragma kernel CalcCellularNoise
#pragma kernel ModifyCellularNoise
#pragma kernel CalcDelaunayTriangulationLine

RWTexture2D<float4> ColorMap;
RWTexture2D<float4> PositionMap;
RWTexture2D<float4> BodyIndexMap;
RWTexture2D<float4> DepthMap;
RWTexture2D<float4> EdgeMap;

RWTexture2D<float4> CellularMap;
RWTexture2D<float4> SeedMap; //xy = seed point of cellular noise, z = index of 'wPoints' that indicates 
RWTexture2D<float4> ExistingLineMap;

StructuredBuffer<uint2> rPoints;
AppendStructuredBuffer<uint2> wPoints; //xy positions for delaunay triangulation
AppendStructuredBuffer<float4> wLines; //lines of delaunay triangulation
int MaxPointNum;

inline float remap(float x, float in_min, float in_max,
                   float out_min, float out_max) {
    float t = (x - in_min) / (in_max - in_min);
    return lerp(out_min, out_max, t);
}

float nrand(float2 uv)
{
    return frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453);
}

float3 hsv(float h, float s, float v)
{
    float4 t = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 p = abs(frac(float3(h,h,h) + t.xyz) * 6.0 - float3(t.w,t.w,t.w));
    return v * lerp(float3(t.x,t.x,t.x), clamp(p - float3(t.x,t.x,t.x), 0.0, 1.0), s);
}

[numthreads(32, 32, 1)]
void ResetCellularNoise(uint2 id : SV_DispatchThreadID)
{
    uint w, h;
    CellularMap.GetDimensions(w, h);
    if (0 <= id.x && id.x < w &&
        0 <= id.y && id.y < h)
    {
        CellularMap[id] = float4(0,0,0,1);
        SeedMap[id] = float4(0,0,0,1);
    }
}

[numthreads(32, 32, 1)]
void ResetExistingLineMap(uint2 id : SV_DispatchThreadID)
{
    uint w, h;
    ExistingLineMap.GetDimensions(w, h);
    if (0 <= id.x && id.x < w &&
        0 <= id.y && id.y < h)
    {
        ExistingLineMap[id] = float4(0,0,0,1);
    }
}

[numthreads(32, 32, 1)]
void GetPoints(uint2 id : SV_DispatchThreadID)
{
    uint w, h;
    BodyIndexMap.GetDimensions(w, h);

    //int isEdge = EdgeMap[id].r > 0;
    int isBody = BodyIndexMap[id].r > 0.0;
    //float edgePointRatio = 0.6 * MaxPointNum / (w * h);
    float bodyPointRatio = 0.4 * MaxPointNum / (w * h);
    //int binary = isEdge && nrand(id.xy * float2(w,h)) < edgePointRatio;
    int isBodyPoint = isBody && nrand(id.xy) < bodyPointRatio;
    //float4 color = float4(isBodyPoint, isBodyPoint, isBodyPoint, 1.0);
    //CellularMap[id] = color;
    if (isBodyPoint) { wPoints.Append(id.xy); }
}

[numthreads(1024, 1, 1)]
void CalcCellularNoise(uint id : SV_DispatchThreadID)
{
    float w, h;
    CellularMap.GetDimensions(w, h);

    float maxPointNumFloat = MaxPointNum;
    if (0 <= id < MaxPointNum &&
        0 <= rPoints[id].x && rPoints[id].x < w &&
        0 <= rPoints[id].y && rPoints[id].y < h)
    {
        float2 seedPoint = rPoints[id]; //母点

        //Calc cellular noise & bake seed point map
        float2 xy = float2(rPoints[id].x / float(w), rPoints[id].y / float(h));
        float4 color = float4(
            nrand(float2(xy.x,0)),
            nrand(float2(0, xy.y)),
            //nrand(float2(id/,0)), //TODO(Tsuku): 辺な円状のノイズが入る
            nrand(id / maxPointNumFloat),
            1.0
        );
        int MaxRadius = 50; // 300px
        for(int r = 0; r < MaxRadius; r++) {
            for(int angle = 0; angle < 360; angle++) {
                float theta = radians(angle);
                float x = r * sin(theta);
                float y = r * cos(theta);
                float2 vicinityXy = rPoints[id] + float2(x,y);
                if (CellularMap[vicinityXy].r <= 0 && BodyIndexMap[vicinityXy].r > 0) {
                    CellularMap[vicinityXy] = color;
                    SeedMap[vicinityXy] = float4(
                        seedPoint.x / w, seedPoint.y / h,
                        id / maxPointNumFloat, 1
                    );
                }
            }
        }
    }
}

[numthreads(32, 32, 1)]
void ModifyCellularNoise(uint2 id : SV_DispatchThreadID)
{
    float w, h;
    SeedMap.GetDimensions(w, h);

    float4 centerColor = CellularMap[id.xy];
    int2 centerSeedPoint = round(SeedMap[id.xy].xy * float2(w,h));
    for (int dy = -1; dy <= 1; dy++) {
        for (int dx = -1; dx <= 1; dx++) {
            int2 vicinityXy = id.xy + float2(dx, dy);
            float4 neighborColor = CellularMap[vicinityXy];
            if (distance(centerColor, neighborColor) != 0)
            {
                int2 neighborSeedPoint = round(SeedMap[vicinityXy].xy * float2(w,h)); //0~1 to 0~w, 0~1 to 0~h
                float dist1 = distance(centerSeedPoint, vicinityXy);
                float dist2 = distance(neighborSeedPoint, vicinityXy);
                CellularMap[vicinityXy] = dist1 < dist2 ? centerColor : neighborColor;
                SeedMap[vicinityXy] = dist1 < dist2 ? SeedMap[id.xy] : SeedMap[vicinityXy];
            }

            /*
            if (0 < seedPoint.x && seedPoint.x < w &&
                0 < seedPoint.y && seedPoint.y < h) {
            }
            */
            
        }
    }
}

[numthreads(32, 32, 1)]
void CalcDelaunayTriangulationLine(uint2 id : SV_DispatchThreadID)
{
    float4 centerColor = CellularMap[id.xy];
    int centerSeedPointIndex = round(SeedMap[id.xy].z * MaxPointNum);
    for (int dy = 0; dy <= 1; dy++) {
        for (int dx = 0; dx <= 1; dx++) {
            int2 vicinityXy = id.xy + float2(dx, dy);
            float4 neighborColor = CellularMap[vicinityXy];

            //If different color
            if (distance(centerColor, neighborColor) != 0)
            {
                int neighborSeedPointIndex = round(SeedMap[vicinityXy].z * MaxPointNum); //0~1 to 0~w, 0~1 to 0~h
                int2 ei = int2(centerSeedPointIndex, neighborSeedPointIndex);
                if (ExistingLineMap[ei].r == 0) {
                    ExistingLineMap[ei] = float4(1,1,1,1);
                    float4 a = float4(SeedMap[id.xy].xy, SeedMap[vicinityXy].xy);
                    wLines.Append(a);
                }
            }
        }
    }
}

/*

[numthreads(32, 32, 1)]
void CalcCellularNoise(uint2 id : SV_DispatchThreadID)
{
    uint width, height;
    CellularMap.GetDimensions(width, height);
    float w = float(width);
    float h = float(height);

    float2 uv = float2(id.x / w, id.y / h);
    uv.x *= w / h;

    float m_dist = 1.0;  // minimum distance
    float3 m_point;        // minimum position

    [loop]
    for (uint i = 0; i < MaxPointNum; i++) {
        float2 p = float2(pointsRead[i].x / w, pointsRead[i].y / h);
        float dist = distance(uv, p);

        // Keep the closer distance
        if (dist < m_dist) {
            m_dist = dist;
            m_point = hsv(nrand(p), 1.0, 1.0);
            //m_point = p;
        }
    }

    //float4 color = float4(m_dist, m_dist, m_dist, 1.0);
    float4 color = float4(m_point, 1.0); 
    CellularMap[id] = color;
}
*/